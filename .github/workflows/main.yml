name: Generate Engaging NBA Script
on:
  workflow_dispatch:
  schedule:
    - cron: '0 */6 * * *'  # Run every 6 hours
  push:
    branches: [ main ]

permissions:
  contents: write

jobs:
  generate-script:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GH_PAT }}
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
        
    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests feedparser playwright beautifulsoup4
        
    - name: Install Playwright browser
      run: playwright install chromium
      
    - name: Create Python script
      run: |
        cat > generate_script.py << 'EOF'
        import os
        import time
        import requests
        import re
        from bs4 import BeautifulSoup
        from playwright.sync_api import sync_playwright, TimeoutError as PlaywrightTimeoutError
        import feedparser
        
        CONFIG = {
            "chunk_size": 40,
            "max_retries": 3,
            "retry_delay": 2,
            "scraper_timeout": 30000,
            "api_timeout": 30,
        }
        
        class EngagingScriptGenerator:
            def __init__(self, config):
                self.config = config
                self.base_url = "https://text.pollinations.ai"
            
            def get_channel_id_from_handle(self, channel_handle):
                try:
                    handle = channel_handle.replace('@', '').replace('https://youtube.com/@', '').replace('https://www.youtube.com/@', '')
                    feed_url = f"https://www.youtube.com/feeds/videos.xml?user={handle}"
                    feed = feedparser.parse(feed_url)
                    
                    if not feed.entries:
                        feed_url = f"https://www.youtube.com/feeds/videos.xml?channel_id={handle}"
                        feed = feedparser.parse(feed_url)
                    
                    if feed.entries:
                        channel_link = feed.feed.get('link', '')
                        if 'channel/' in channel_link:
                            return channel_link.split('channel/')[-1]
                    return None
                except Exception as e:
                    print(f"Error getting channel ID: {e}")
                    return None
            
            def get_latest_video_id_from_channel_id(self, channel_id):
                feed_url = f"https://www.youtube.com/feeds/videos.xml?channel_id={channel_id}"
                feed = feedparser.parse(feed_url)
                if feed.entries:
                    video_link = feed.entries[0].link
                    video_id_match = re.search(r"v=([a-zA-Z0-9_-]+)", video_link)
                    if video_id_match:
                        return video_id_match.group(1)
                return None
            
            def get_youtube_transcript(self, video_id):
                youtube_url = f"https://youtu.be/{video_id}"
                
                with sync_playwright() as p:
                    browser = p.chromium.launch(headless=True)
                    page = browser.new_page()
                    
                    try:
                        page.goto("https://youtubetotranscript.com/", timeout=self.config["scraper_timeout"])
                        page.wait_for_load_state("networkidle", timeout=self.config["scraper_timeout"])
                        
                        input_selector = "input.w-full.mb-2.truncate.input.input-bordered.input-rounded.sm\\:w-sm.sm\\:mb-0.sm\\:mr-2"
                        page.wait_for_selector(input_selector, timeout=self.config["scraper_timeout"])
                        page.fill(input_selector, youtube_url)
                        
                        button_selector = "button.w-full.btn.btn-secondary.btn-rounded.sm\\:w-auto"
                        page.click(button_selector)
                        page.wait_for_load_state("networkidle", timeout=self.config["scraper_timeout"])
                        time.sleep(3)
                        
                        html_content = page.content()
                        soup = BeautifulSoup(html_content, 'html.parser')
                        transcript_div = soup.find('div', {'id': 'transcript'})
                        
                        if not transcript_div:
                            raise Exception("Transcript container not found")
                        
                        segments = transcript_div.find_all('span', class_='transcript-segment')
                        if not segments:
                            raise Exception("No transcript segments found")
                        
                        transcript_text = " ".join(seg.get_text().strip() for seg in segments if seg.get_text().strip())
                        return transcript_text.strip()
                        
                    except Exception as e:
                        print(f"Transcript extraction failed: {str(e)}")
                        return ""
                    finally:
                        browser.close()
            
            def split_into_chunks(self, transcript, chunk_size=40):
                words = transcript.split()
                chunks = []
                current_chunk = []
                current_count = 0
                
                for word in words:
                    current_chunk.append(word)
                    current_count += 1
                    
                    if current_count >= chunk_size:
                        chunks.append(' '.join(current_chunk))
                        current_chunk = []
                        current_count = 0
                
                if current_chunk:
                    chunks.append(' '.join(current_chunk))
                
                return chunks
            
            def enhance_chunk(self, chunk, chunk_index, total_chunks):
                if chunk_index == 0:  # Opening hook
                    prompt = f"Transform this into an irresistible YouTube opening that hooks viewers instantly. Make it conversational, exciting, and add [PAUSE] markers. Use phrases like 'You won't believe what just happened' or 'This changes everything'. Content: {chunk}"
                elif chunk_index < total_chunks // 2:  # Build engagement
                    prompt = f"Rewrite this to build massive intrigue with mini-cliffhangers. Add transitions like 'But here's where it gets crazy...' and strategic [PAUSE] markers. Make it engaging and conversational. Content: {chunk}"
                else:  # Strong finish
                    prompt = f"Transform this into powerful content that delivers impact. Add [PAUSE] markers and use phrases like 'Here's what this means...' or 'The bottom line is...'. Make it memorable. Content: {chunk}"
                
                return self.make_api_request(prompt)
            
            def make_api_request(self, prompt):
                encoded_prompt = requests.utils.quote(prompt)
                url = f"{self.base_url}/{encoded_prompt}"
                
                for attempt in range(self.config["max_retries"]):
                    try:
                        response = requests.get(url, timeout=self.config["api_timeout"])
                        if response.status_code == 200:
                            return response.text.strip()
                        elif response.status_code == 429:
                            delay = self.config["retry_delay"] * (2 ** attempt)
                            time.sleep(delay)
                            continue
                        else:
                            return None
                    except Exception as e:
                        if attempt < self.config["max_retries"] - 1:
                            time.sleep(self.config["retry_delay"] * (2 ** attempt))
                        else:
                            return None
                return None
            
            def final_polish(self, script):
                polish_prompt = f"""Make this YouTube script incredibly engaging by:
                1. Adding strategic hooks every 60 seconds to keep viewers watching
                2. Fixing any player names or factual errors
                3. Adding smooth transitions between topics
                4. Optimizing [PAUSE] markers for perfect TTS delivery
                5. Creating a powerful opening and strong ending
                6. Making it conversational and binge-worthy
                
                Script: {script}"""
                
                polished = self.make_api_request(polish_prompt)
                return polished if polished else script
            
            def generate_engaging_script(self, channel_handle):
                print("ðŸš€ Starting engaging script generation...")
                
                # Get channel ID
                if channel_handle.startswith('UC') and len(channel_handle) == 24:
                    channel_id = channel_handle
                else:
                    channel_id = self.get_channel_id_from_handle(channel_handle)
                    if not channel_id and 'amhoops' in channel_handle.lower():
                        channel_id = "UCtG-elouHQdUnpN9cVLdltg"
                
                if not channel_id:
                    print("âŒ Could not get channel ID")
                    return None
                
                # Get latest video and transcript
                latest_video_id = self.get_latest_video_id_from_channel_id(channel_id)
                if not latest_video_id:
                    return None
                
                original_transcript = self.get_youtube_transcript(latest_video_id)
                if not original_transcript:
                    return None
                
                print(f"ðŸ“ Processing {len(original_transcript.split())} words...")
                
                # Transform chunks with engagement
                chunks = self.split_into_chunks(original_transcript, self.config["chunk_size"])
                transformed_chunks = []
                
                for i, chunk in enumerate(chunks):
                    print(f"âš¡ Enhancing chunk {i+1}/{len(chunks)}...")
                    enhanced = self.enhance_chunk(chunk, i, len(chunks))
                    transformed_chunks.append(enhanced if enhanced else chunk)
                    time.sleep(0.8)
                
                # Final polish
                raw_script = '\n\n'.join(transformed_chunks)
                final_script = self.final_polish(raw_script)
                
                if final_script:
                    with open("s1.txt", "w", encoding="utf-8") as f:
                        f.write(final_script)
                    
                    print(f"âœ… Engaging script created: {len(final_script.split())} words")
                    return final_script
                
                return None
        
        def main():
            generator = EngagingScriptGenerator(CONFIG)
            CHANNEL_HANDLE = "https://youtube.com/@amhoops"
            
            print("ðŸŽ¬ Engagement-Focused YouTube Script Generator")
            script = generator.generate_engaging_script(CHANNEL_HANDLE)
            
            if script:
                print("ðŸŽ‰ SUCCESS: Engagement-optimized script ready!")
            else:
                print("âŒ Script generation failed")
            
            return script
        
        if __name__ == "__main__":
            main()
        EOF
        
    - name: Run script generation
      timeout-minutes: 30
      run: |
        python generate_script.py
        [ -f "s1.txt" ] && echo "âœ… s1.txt created" || echo "âŒ s1.txt not found"
        rm -f generate_script.py
      
    - name: Set up Git identity
      run: |
        git config --global user.name "cowboycode9"
        git config --global user.email "cowboycode9@outlook.com"
        
    - name: Commit and push script
      run: |
        if [ -f "s1.txt" ]; then
          git add s1.txt
          if ! git diff --staged --quiet; then
            git commit -m "ðŸ”¥ Generated engaging NBA script - $(date '+%Y-%m-%d %H:%M:%S')"
            git push
            echo "âœ… Script pushed successfully!"
          fi
        fi            
            def post_process_script(self, script):
                """Enhanced post-processing for maximum engagement."""
                
                post_process_prompt = f"""
                Take this YouTube script and make it INCREDIBLY engaging and binge-worthy. Apply these techniques:
                
                1. ADD STRATEGIC HOOKS: Insert retention hooks every 30-60 seconds
                2. IMPROVE FLOW: Add smooth transitions between topics  
                3. CREATE CURIOSITY GAPS: Tease information before revealing it
                4. ADD CALL-OUTS: Include viewer engagement like "Comment below if you agree"
                5. STRENGTHEN OPENING: Make first 15 seconds absolutely irresistible
                6. POWERFUL ENDING: Strong call-to-action and subscribe prompt
                7. OPTIMIZE PACING: Add [PAUSE] markers for perfect TTS delivery
                8. FIX ANY ERRORS: Correct player names, facts, and grammar
                
                Make this script so engaging that viewers CAN'T stop watching. Here's the script:
                
                {script}
                """
                
                enhanced_script = self.make_api_request(post_process_prompt)
                return enhanced_script if enhanced_script else script
            
            def generate_engaging_script(self, channel_handle):
                """Generate an incredibly engaging YouTube script."""
                
                print("ðŸš€ ENGAGING SCRIPT GENERATOR ACTIVATED!")
                print("ðŸŽ¯ Mission: Create content so good viewers can't click away")
                print("-" * 60)
                
                # Get channel ID
                if channel_handle.startswith('UC') and len(channel_handle) == 24:
                    channel_id = channel_handle
                else:
                    channel_id = self.get_channel_id_from_handle(channel_handle)
                    if not channel_id:
                        if 'amhoops' in channel_handle.lower():
                            channel_id = "UCtG-elouHQdUnpN9cVLdltg"
                        else:
                            print("âŒ Could not get channel ID")
                            return None
                
                print(f"âœ… Target Channel ID: {channel_id}")
                
                # Get latest video
                latest_video_id = self.get_latest_video_id_from_channel_id(channel_id)
                if not latest_video_id:
                    print("âŒ Could not find latest video")
                    return None
                
                print(f"ðŸŽ¬ Latest Video ID: {latest_video_id}")
                
                # Get transcript
                original_transcript = self.get_youtube_transcript(latest_video_id)
                if not original_transcript:
                    print("âŒ Could not fetch transcript")
                    return None
                
                print(f"ðŸ“ Original transcript: {len(original_transcript.split())} words")
                
                # Split into strategic chunks
                chunks = self.split_into_chunks(original_transcript, self.config["chunk_size"])
                print(f"ðŸ§© Created {len(chunks)} strategic chunks")
                
                # Transform each chunk with engagement techniques
                print("\nðŸ”¥ APPLYING ENGAGEMENT TECHNIQUES...")
                transformed_chunks = []
                failed_chunks = 0
                
                for i, chunk in enumerate(chunks):
                    print(f"âš¡ Transforming chunk {i+1}/{len(chunks)} with engagement boost...")
                    
                    enhanced_chunk = self.enhance_chunk_with_engagement(chunk, i, len(chunks))
                    
                    if enhanced_chunk:
                        print(f"âœ… Chunk {i+1} transformed successfully!")
                        transformed_chunks.append(enhanced_chunk)
                    else:
                        print(f"âŒ Failed to transform chunk {i+1}")
                        transformed_chunks.append(chunk)
                        failed_chunks += 1
                    
                    # Strategic delay to avoid rate limits
                    time.sleep(1)
                
                # Combine and enhance full script
                raw_script = '\n\n'.join(transformed_chunks)
                
                print("\nðŸŽ¨ APPLYING FINAL ENGAGEMENT POLISH...")
                final_script = self.post_process_script(raw_script)
                
                if final_script:
                    print(f"\nðŸŽ‰ ENGAGEMENT-OPTIMIZED SCRIPT CREATED!")
                    print(f"ðŸ“Š Final word count: {len(final_script.split())} words")
                    print(f"ðŸŽ¬ Estimated watch time: {len(final_script.split()) // 150}-{len(final_script.split()) // 130} minutes")
                    print(f"âš ï¸ Failed chunks: {failed_chunks}/{len(chunks)}")
                    
                    # Save the engaging script
                    with open("s1.txt", "w", encoding="utf-8") as f:
                        f.write(final_script)
                    
                    print("âœ… BINGE-WORTHY SCRIPT SAVED AS s1.txt!")
                    
                    # Show preview
                    print("\nðŸ“º SCRIPT PREVIEW:")
                    print("=" * 50)
                    preview = final_script[:400].replace('\n', ' ')
                    print(f"{preview}...")
                    print("=" * 50)
                    print("ðŸŽ¯ This script is designed to maximize viewer retention!")
                    
                    return final_script
                
                return None
        
        def main():
            generator = EngagingScriptGenerator(CONFIG)
            
            CHANNEL_HANDLE = "https://youtube.com/@amhoops"
            
            print("ðŸŽ¬ ENGAGEMENT-FOCUSED YOUTUBE SCRIPT GENERATOR")
            print("=" * 60)
            print("ðŸŽ¯ OBJECTIVE: Create irresistible content that hooks viewers")
            print("ðŸ”¥ TECHNIQUES: Story hooks, curiosity gaps, pattern interrupts")
            print("âš¡ OPTIMIZATION: Maximum retention and engagement")
            print("ðŸŽ™ï¸ TTS READY: Perfect pacing with strategic pauses")
            print("=" * 60)
            
            script = generator.generate_engaging_script(CHANNEL_HANDLE)
            
            if script:
                print("\nðŸ† SUCCESS: ENGAGEMENT-O
